#ifdef _WIN32
    #include <stdio.h>
    #include <stdlib.h>
    int main() {
        printf("Platform Detected: Windows\n\n");
        fprintf(stderr, "\033[1;31m[-] ERROR: This program is designed to run on Unix-like systems only.\033[0m\n");
        fprintf(stderr, "[-] Please use a Unix-like operating system to run this program.\n\n");
        fprintf(stderr, "Exiting...\n");
        exit(EXIT_FAILURE);
    }
#else

#include <arpa/inet.h>
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>

#define CLEAR_SCREEN system("clear")
#define GET_NUM_CORES() (sysconf(_SC_NPROCESSORS_ONLN))
#define INET_ADDRSTRLEN 16

void banner();
void port_scan(struct sockaddr_in serv_addr, const char* ip_addr, int choice, int start_port, int end_port);
int calculate_optimal_threads(); // Defining Optimal Thread Count
int scan_menu();
void* port_scan_thread(void* arg);

// Arguments of port scan thread
typedef struct {
    struct sockaddr_in serv_addr;
    char ip_addr[INET_ADDRSTRLEN];
    int choice;
    int start_port;
    int end_port;
} PortScanParams;

// Global variable to count open ports
int open_port_count = 0;
pthread_mutex_t count_mutex;

void* port_scan_thread(void* arg) {
    PortScanParams* params = (PortScanParams*)arg;
    port_scan(params->serv_addr, params->ip_addr, params->choice, params->start_port, params->end_port);
    free(params); // Free the allocated memory for the parameters
    return NULL;
}

void port_scan(struct sockaddr_in serv_addr, const char* ip_addr, int choice, int start_port, int end_port) {    
    for (int port = start_port; port <= end_port; port++) {
        int client_fd = socket(AF_INET, SOCK_STREAM, 0);
        if (client_fd < 0) {
            // Socket creation error
            continue;
        }

        serv_addr.sin_family = AF_INET;
        serv_addr.sin_port = htons(port);

        // Convert current IPv4 to binary format 
        if (inet_pton(AF_INET, ip_addr, &serv_addr.sin_addr) <= 0) {
            // Conversion error
            close(client_fd);
            continue;
        }

        // Attempt to connect to server with desired port
        if (connect(client_fd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
            // Print a statement here if you want to view closed ports (will result in several values)
        } else {
            printf("\033[1;32m[+] Port %d open\033[0m\n", port);
            // Increment the global open port count
            pthread_mutex_lock(&count_mutex);
            open_port_count++;
            pthread_mutex_unlock(&count_mutex);
        }

        close(client_fd); // Close the socket after each attempt 
    }
}

int scan_menu() {
    CLEAR_SCREEN;

    int user_choice;
    printf("\n");
    printf("========================================\n");
    printf("||                                    ||\n");
    printf("||         Welcome to Netprobe        ||\n");
    printf("||                                    ||\n");
    printf("========================================\n");
    printf("||                                    ||\n");
    printf("||         PORT SCANNER MENU          ||\n");
    printf("||                                    ||\n");
    printf("========================================\n");
    printf("||                                    ||\n");
    printf("||  1) Scan all ports                 ||\n");
    printf("||  2) Scan a range of ports          ||\n");
    printf("||                                    ||\n");
    printf("========================================\n\n");
    while (1) {
        printf("Enter your choice (1 or 2): ");
        if (scanf("%d", &user_choice) != 1) {
            fprintf(stderr, "Invalid format detected! Exiting . . . \n");
            exit(EXIT_FAILURE);
        }

        if (user_choice < 1 || user_choice > 2) {
            printf("Invalid choice! Please enter a value between 1 and 2. Try again \n");
            continue;
        } else {
            break;
        }
    }

    while (getchar() != '\n'); // Clear new line character for 'fgets'

    return user_choice;
}

void banner() {
    printf(
        " _        _______ _________ _______  _______  _______  ______   _______ \n"
        "( (    /|(  ____ \\__   __/(  ____ )(  ____ )(  ___  )(  ___ \\ (  ____ \\ \n"
        "|  \\  ( || (    \\/   ) (   | (    )|| (    )|| (   ) || (   ) )| (    \\/ \n"
        "|   \\ | || (__       | |   | (____)|| (____)|| |   | || (__/ / | (__    \n"
        "| (\\ \\) ||  __)      | |   |  _____)|     __)| |   | ||  __ (  |  __)   \n"
        "| | \\   || (         | |   | (      | (\\ (   | |   | || (  \\ \\ | (      \n"
        "| )  \\  || (____/\\   | |   | )      | ) \\ \\__| (___) || )___) )| (____/\\ \n"
        "|/    )_)(_______/   )_(   |/       |/   \\__/(___ ___)|/ \\___/ (_______/ \n\n");
}

int calculate_optimal_threads() {
    int num_cores = GET_NUM_CORES();
    return num_cores * 4; // Using a multiplier of 4 for I/O-bound tasks
}

int main() {
    int max_threads = calculate_optimal_threads();
    int user_choice = scan_menu();

    struct sockaddr_in serv_addr;
    char ip_addr[INET_ADDRSTRLEN] = {}; // Default IP value (blank), size of IPv4 value
    int start_port = 1, end_port = 65535; // Default port values

    while (1) {
        printf("Enter the IP address you want to scan > ");
        if (fgets(ip_addr, sizeof(ip_addr), stdin) == NULL) {
            fprintf(stderr, "[-] Blank input! Please enter a value for the IP address. Try again.\n");
            continue; // continue to prompt for input on invalid entry
        }
        // Strip the newline character which fgets reads if there's space
        ip_addr[strcspn(ip_addr, "\n")] = '\0';

        int found = 0;
        // Check the format of the IP address
        for (int i = 0; ip_addr[i] != '\0'; i++) {
            if (ip_addr[i] == '.') {
                found++;
            }
        }

        if (found == 3) {
            break; // Correct IP format
        } else {
            fprintf(stderr, "[-] Incorrect format for IP address. Try again.\n");
        }
    }

    // Scanning varies depending on choice
    if (user_choice == 2) {
        while (1) {
            printf("Enter start port: ");
            if (scanf("%d", &start_port) != 1) {
                fprintf(stderr, "Invalid format detected! Exiting . . . \n");
                exit(EXIT_FAILURE);
            } else if (start_port > 65535 || start_port <= 0) {
                printf("[-] Invalid start port number, please ensure it is between 1 and 65535! Try again \n");
                continue;
            }

            printf("Enter end port: ");
            if (scanf("%d", &end_port) != 1) {
                fprintf(stderr, "Invalid format detected! Exiting . . . \n");
                exit(EXIT_FAILURE);
            } else if (end_port > 65535 || end_port <= 0) {
                printf("[-] Invalid end port number, please ensure it is between 1 and 65535! Try again \n");
                continue;
            }

            // Take account for human error
            if (end_port < start_port) {
                int temp = start_port;
                start_port = end_port;
                end_port = temp;
            }
            break;
        }
    }

    // Redirect user to netprobe
    printf("\n[!] OPTIONS SELECTED -> Starting up NetProbe . . . \n");
    sleep(2);
    CLEAR_SCREEN;
    banner();
    if (user_choice == 1) {
        printf("\n[!] Full port Scan Selected -> Scanning from %d to %d \n", start_port, end_port);
    } else {
        printf("\n[!] Range Options Selected -> Scanning from %d to %d \n", start_port, end_port);
    }
    printf("INFO: PRESS CTRL+C TO TERMINATE PROGRAM . . . \n\n");

    // Initialize the mutex
    if (pthread_mutex_init(&count_mutex, NULL) != 0) {
        fprintf(stderr, "Failed to initialize mutex.\n");
        return 1;
    }

    // Calculate the number of ports each thread will handle
    int total_ports = end_port - start_port + 1; // Add one so loop covers all ports
    int ports_per_thread = total_ports / max_threads; // What each thread will handle
    int remainder = total_ports % max_threads; // Handle any remainders

    // Create threads
    pthread_t threads[max_threads];
    for (int i = 0; i < max_threads; i++) {
        int thread_start_port = start_port + i * ports_per_thread;
        int thread_end_port = thread_start_port + ports_per_thread - 1;
        if (i == max_threads - 1) {
            thread_end_port += remainder; // Last thread gets the remainder ports
        }

        PortScanParams* params = (PortScanParams*)malloc(sizeof(PortScanParams));
        params->serv_addr = serv_addr;
        strcpy(params->ip_addr, ip_addr);
        params->choice = user_choice;
        params->start_port = thread_start_port;
        params->end_port = thread_end_port;

        if (pthread_create(&threads[i], NULL, port_scan_thread, (void*)params) != 0) {
            fprintf(stderr, "Error when creating thread with ID %d. Aborting! \n", i);
            exit(EXIT_FAILURE);
        }
    }

    // Join threads
    for (int i = 0; i < max_threads; i++) {
        if (pthread_join(threads[i], NULL) != 0) {
            fprintf(stderr, "Error when joining thread with ID %d. Aborting! \n", i);
            exit(EXIT_FAILURE);
        }
    }

    // Destroy the mutex
    pthread_mutex_destroy(&count_mutex);

    // Print the total number of open ports found
    if (open_port_count == 0){
        printf("\nNo open ports where found, this can be due to a present firewall ... \n");
    }else{
        printf("\nTotal open ports found open : %d \n", open_port_count);
    }

    printf("[!] Port scan operation finished, Goodbye \n");

    return 0;
}

#endif
